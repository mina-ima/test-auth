<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Supabase Auth Demo</title>
  <style>
    :root {
      color-scheme: light;
      font-family: "Helvetica Neue", Arial, sans-serif;
      background: #f6f8fb;
      color: #1f2a44;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
    }

    .card {
      width: min(1100px, 96vw);
      background: #fff;
      padding: 32px 28px;
      border-radius: 16px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.08);
      text-align: center;
    }

    h1 {
      margin: 0 0 8px;
      font-size: 22px;
      letter-spacing: 0.4px;
    }

    p {
      margin: 0 0 20px;
      color: #4b5563;
      line-height: 1.6;
      font-size: 14px;
    }

    button {
      cursor: pointer;
      border: none;
      border-radius: 10px;
      padding: 12px 16px;
      font-size: 15px;
      font-weight: 700;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
    }

    .btn-primary {
      width: 100%;
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      color: #fff;
      box-shadow: 0 8px 24px rgba(37, 99, 235, 0.35);
    }

    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 30px rgba(37, 99, 235, 0.35);
    }

    .btn-ghost {
      width: 100%;
      background: #eef2ff;
      color: #1f2a44;
    }

    .btn-ghost:hover {
      background: #e0e7ff;
    }

    .btn-secondary {
      width: 100%;
      background: #dbeafe;
      color: #1d4ed8;
      border: 1px solid #bfdbfe;
    }

    .btn-secondary:hover {
      background: #bfdbfe;
    }

    .status {
      margin-bottom: 18px;
      padding: 12px;
      background: #f8fafc;
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      font-size: 14px;
    }

    #actions {
      display: grid;
      gap: 12px;
    }

    input[type="text"],
    input[type="url"] {
      width: 100%;
      box-sizing: border-box;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #e5e7eb;
      font-size: 14px;
      background: #f8fafc;
    }

    input[type="text"]:focus,
    input[type="url"]:focus {
      outline: 2px solid #bfdbfe;
      background: #fff;
    }

    .editor-wrapper {
      display: grid;
      gap: 12px;
      text-align: left;
    }

    .editor-actions {
      display: grid;
      gap: 10px;
    }

    .editor-actions.inline-grid {
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      align-items: center;
    }

    .muted {
      color: #6b7280;
      font-size: 14px;
    }

    .link-row {
      display: grid;
      gap: 8px;
      align-items: start;
    }

    .qr-box {
      justify-self: center;
      padding: 10px;
      border: 1px dashed #e5e7eb;
      border-radius: 12px;
      background: #f8fafc;
    }

    .qr-box img {
      display: block;
      width: 200px;
      height: 200px;
      object-fit: contain;
    }

    .table-wrapper {
      width: 100%;
      overflow: auto;
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      background: #fff;
    }

    .table-grid {
      width: 100%;
      min-width: 720px;
      border-collapse: collapse;
      table-layout: fixed;
    }

    .table-grid th,
    .table-grid td {
      border-bottom: 1px solid #e5e7eb;
      padding: 10px 12px;
      text-align: left;
      font-size: 14px;
    }

    .table-grid th {
      background: #f8fafc;
      color: #4b5563;
      position: sticky;
      top: 0;
      z-index: 1;
    }

    .table-grid td.cell-num {
      width: 44px;
      text-align: center;
      color: #6b7280;
      font-weight: 600;
    }

    .table-grid td.cell-edit {
      background: #fffdfa;
      min-width: 160px;
    }

    .table-grid td.cell-edit:focus {
      outline: 2px solid #bfdbfe;
      border-radius: 6px;
    }

    .table-grid .cell-check {
      text-align: center;
      width: 90px;
    }

    .table-grid input[type="checkbox"] {
      width: 18px;
      height: 18px;
    }
  </style>
</head>
<body>
  <div class="card" id="card">
    <h1>Supabase Auth</h1>
    <p>Googleでログインして、状態を確認できます。</p>
    <div id="status" class="status" role="status">読み込み中...</div>
    <div id="actions"></div>
  </div>

  <!-- Optional: env.js (gitignored) should define window.__ENV__ from environment variables -->
  <script src="./env.js"></script>
  <script type="module">
    // Supabase settings read from environment (populate via env.js using env vars)
    const env = globalThis.__ENV__ || {};
    const SUPABASE_URL = env.SUPABASE_URL || "";
    const SUPABASE_ANON_KEY = env.SUPABASE_ANON_KEY || "";
    const MAX_SHORTCUTS = 10;

    const normalizeEmail = (val = "") => val.replace(/[\u200B-\u200D\uFEFF]/g, "").trim().toLowerCase();
    const escapeHtml = (val = "") =>
      String(val)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    const boolFromText = (val, defaultValue = false) => {
      if (val === undefined || val === null) return defaultValue;
      const normalized = String(val).trim().toLowerCase();
      if (!normalized) return defaultValue;
      return ["true", "1", "yes", "y", "on", "ok", "✓", "○"].includes(normalized);
    };

    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.4/+esm";
    import QRCode from "https://cdn.jsdelivr.net/npm/qrcode@1.5.3/+esm";

    const statusEl = document.getElementById("status");
    const actionsEl = document.getElementById("actions");

    if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
      statusEl.textContent = "環境変数からSupabaseの設定値を注入してください。";
      actionsEl.innerHTML = "";
      throw new Error("Supabase settings are empty.");
    }

    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: {
        persistSession: false, // do not keep sessions between page loads
        autoRefreshToken: false,
      },
    });

    const setupGridPaste = (tbody, columns = [], appendRow) => {
      if (!tbody || !columns.length || typeof appendRow !== "function") return;
      tbody.addEventListener("paste", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) return;
        const field = target.dataset?.field;
        if (!columns.some((c) => c.key === field)) return;

        const text = (event.clipboardData || window.clipboardData)?.getData("text") || "";
        if (!text) return;
        event.preventDefault();

        const rows = text
          .split(/\r?\n/)
          .map((line) => line.split("\t"))
          .filter((cols) => cols.some((c) => c.trim() !== ""));
        if (!rows.length) return;

        const allRows = Array.from(tbody.querySelectorAll("tr"));
        const startRow = Math.max(0, allRows.indexOf(target.closest("tr")));
        const ensureRow = (idx) => {
          while (tbody.querySelectorAll("tr").length <= idx) {
            appendRow();
          }
        };

        rows.forEach((cols, rowOffset) => {
          const targetIndex = startRow + rowOffset;
          ensureRow(targetIndex);
          const rowEl = tbody.querySelectorAll("tr")[targetIndex];
          columns.forEach((colDef, colIndex) => {
            const rawVal = cols[colIndex];
            if (rawVal === undefined) {
              if (colDef.type === "bool" && colDef.defaultTrue) {
                const checkbox = rowEl.querySelector(`input[data-field="${colDef.key}"]`);
                if (checkbox) checkbox.checked = true;
              }
              return;
            }
            if (colDef.type === "bool") {
              const checkbox = rowEl.querySelector(`input[data-field="${colDef.key}"]`);
              if (checkbox) checkbox.checked = boolFromText(rawVal, !!colDef.defaultTrue);
            } else {
              const cell = rowEl.querySelector(`[data-field="${colDef.key}"]`);
              if (cell) cell.textContent = rawVal.trim();
            }
          });
        });
      });
    };

    const getEditMode = () => new URL(window.location.href).searchParams.get("edit") || "";
    const setEditMode = (mode = "") => {
      const url = new URL(window.location.href);
      if (mode) {
        url.searchParams.set("edit", mode);
      } else {
        url.searchParams.delete("edit");
      }
      window.history.replaceState({}, "", url);
    };

    let latestContext = { email: "", shortcuts: [], apps: [], userApps: [], canEditApps: false, canEditUsers: false, isAdmin: false };

    const attachQrHandlers = () => {
      const qrButtons = Array.from(document.querySelectorAll(".btn-qr"));
      qrButtons.forEach((btn) => {
        btn.addEventListener("click", async () => {
          const targetId = btn.dataset?.target;
          const url = btn.dataset?.url || "";
          const box = targetId ? document.getElementById(targetId) : null;
          if (!box || !url) return;

          // toggle hide/show
          if (!box.hasAttribute("hidden")) {
            box.setAttribute("hidden", "true");
            box.innerHTML = "";
            btn.textContent = "QRコード";
            return;
          }

          btn.textContent = "生成中...";
          try {
            const dataUrl = await QRCode.toDataURL(url, {
              width: 220,
              margin: 1,
              errorCorrectionLevel: "M",
            });
            box.innerHTML = `<img src="${dataUrl}" alt="QR: ${url}" />`;
            box.removeAttribute("hidden");
            btn.textContent = "閉じる";
          } catch (err) {
            console.error("QR generation failed", err);
            btn.textContent = "エラー";
            setTimeout(() => { btn.textContent = "QRコード"; }, 1400);
          }
        });
      });
    };

    const renderSignedOut = () => {
      statusEl.textContent = "ログインしていません。";
      setEditMode("");
      latestContext = { email: "", shortcuts: [], apps: [], userApps: [], canEditApps: false, canEditUsers: false, isAdmin: false };
      actionsEl.innerHTML = `
        <button class="btn-primary" id="login-btn">Googleでログイン</button>
      `;

      const loginBtn = document.getElementById("login-btn");
      loginBtn?.addEventListener("click", async () => {
        statusEl.textContent = "リダイレクトしています...";
        await supabase.auth.signInWithOAuth({
          provider: "google",
          options: {
            redirectTo: window.location.href,
            queryParams: { prompt: "login" }, // force credential entry each time
          },
        });
      });
    };

    const renderSignedIn = (ctx = {}) => {
      const { email = "", shortcuts = [], canEditApps = false, canEditUsers = false } = ctx;
      statusEl.textContent = `ようこそ、${email} さん`;

      // If no shortcuts, fall back to the previous hardcoded links.
      const fallbackLinks =
        email === "minamidenshi@gmail.com"
          ? [
              { label: "皆見電子ホームページへ", url: "https://www.mdk-j.com" },
              { label: "ChizuPazzleへ", url: "https://chizupazzle.vercel.app" },
            ]
          : [{ label: "Googleサイトへ", url: "https://www.google.com" }];

      const linksToRender = (shortcuts?.length ? shortcuts : fallbackLinks).slice(0, MAX_SHORTCUTS);

      const linksMarkup = linksToRender
        .map(
          (link, idx) => `
            <div class="link-row">
              <a class="btn-primary" id="shortcut-${idx}" href="${link.url}" target="_blank" rel="noopener noreferrer">${link.label}</a>
              <button class="btn-ghost btn-qr" data-url="${link.url}" data-target="qr-${idx}">QRコード</button>
              <div class="qr-box" id="qr-${idx}" hidden></div>
            </div>
          `
        )
        .join("\n");

      const editButtonMarkup = canEditApps
        ? `<button class="btn-secondary" id="edit-btn">アプリを追加/編集</button>`
        : "";

      const userButtonMarkup = canEditUsers
        ? `<button class="btn-secondary" id="user-btn">ユーザー割当を編集</button>`
        : "";

      actionsEl.innerHTML = `
        ${linksMarkup || `<p class="muted">表示できるリンクがありません。</p>`}
        ${editButtonMarkup}
        ${userButtonMarkup}
        <button class="btn-ghost" id="logout-btn">ログアウト</button>
      `;

      const logoutBtn = document.getElementById("logout-btn");
      logoutBtn?.addEventListener("click", async () => {
        statusEl.textContent = "ログアウトしています...";
        await supabase.auth.signOut();
      });

      attachQrHandlers();

      if (canEditApps) {
        const editBtn = document.getElementById("edit-btn");
        editBtn?.addEventListener("click", () => {
          setEditMode("apps");
          renderAppManager(latestContext);
        });
      }

      if (canEditUsers) {
        const userBtn = document.getElementById("user-btn");
        userBtn?.addEventListener("click", () => {
          setEditMode("users");
          renderUserManager(latestContext);
        });
      }
    };

    const renderAppManager = (ctx) => {
      if (!ctx?.canEditApps) {
        setEditMode("");
        renderSignedIn({ email: ctx?.email || "", shortcuts: ctx?.shortcuts || [], canEditApps: false, canEditUsers: false });
        return;
      }

      const appsToRender = ctx.apps && ctx.apps.length ? ctx.apps : [];
      statusEl.textContent = `${ctx.email} さんはアプリを追加・編集できます。`;

      const renderAppRow = (item, idx) => `
        <tr data-index="${idx}">
          <td class="cell-num">${idx + 1}</td>
          <td class="cell-edit" contenteditable="true" data-field="app_no" spellcheck="false">${escapeHtml(item.app_no || "")}</td>
          <td class="cell-edit" contenteditable="true" data-field="label">${escapeHtml(item.label || "")}</td>
          <td class="cell-edit" contenteditable="true" data-field="url" spellcheck="false">${escapeHtml(item.url || "")}</td>
        </tr>
      `;

      const blankRowCount = Math.max(3, 5 - appsToRender.length);
      const existingRowsMarkup = appsToRender.map((item, idx) => renderAppRow(item, idx)).join("\n");
      const blankRowsMarkup = Array.from({ length: blankRowCount })
        .map((_, i) => renderAppRow({ app_no: "", label: "", url: "" }, appsToRender.length + i))
        .join("\n");

      actionsEl.innerHTML = `
        <div class="editor-wrapper">
          <p class="muted">スプレッドシートと同じ感覚で入力・貼り付けできます。列は「App No / ラベル / URL」の順です。</p>
          <form id="apps-form">
            <div class="table-wrapper">
              <table class="table-grid" id="apps-table">
                <thead>
                  <tr>
                    <th>#</th>
                    <th>App No</th>
                    <th>ラベル</th>
                    <th>URL</th>
                  </tr>
                </thead>
                <tbody id="apps-tbody">
                  ${existingRowsMarkup}
                  ${blankRowsMarkup}
                </tbody>
              </table>
            </div>
            <div class="editor-actions inline-grid">
              <button class="btn-secondary" type="button" id="add-app-row">空行を1行追加</button>
              <button class="btn-secondary" type="button" id="add-five-app-rows">空行を5行追加</button>
              <button class="btn-primary" type="submit" id="save-btn">保存する</button>
            </div>
          </form>
          <div class="editor-actions">
            <button class="btn-ghost" type="button" id="back-btn">一覧に戻る</button>
            <button class="btn-ghost" id="logout-btn">ログアウト</button>
          </div>
        </div>
      `;

      const tbody = document.getElementById("apps-tbody");
      const addAppRow = (count = 1) => {
        if (!tbody) return;
        const start = tbody.querySelectorAll("tr").length;
        const rowsMarkup = Array.from({ length: count })
          .map((_, i) => renderAppRow({ app_no: "", label: "", url: "" }, start + i))
          .join("\n");
        tbody.insertAdjacentHTML("beforeend", rowsMarkup);
      };

      setupGridPaste(
        tbody,
        [
          { key: "app_no", type: "text" },
          { key: "label", type: "text" },
          { key: "url", type: "text" },
        ],
        () => addAppRow(1)
      );

      document.getElementById("add-app-row")?.addEventListener("click", () => addAppRow(1));
      document.getElementById("add-five-app-rows")?.addEventListener("click", () => addAppRow(5));

      const logoutBtn = document.getElementById("logout-btn");
      logoutBtn?.addEventListener("click", async () => {
        statusEl.textContent = "ログアウトしています...";
        await supabase.auth.signOut();
      });

      const backBtn = document.getElementById("back-btn");
      backBtn?.addEventListener("click", () => {
        setEditMode("");
        renderSignedIn({ ...ctx, canEditApps: ctx.canEditApps, canEditUsers: ctx.canEditUsers });
      });

      const form = document.getElementById("apps-form");
      form?.addEventListener("submit", async (event) => {
        event.preventDefault();
        const rows = Array.from(tbody?.querySelectorAll("tr") || []);
        const seen = new Set();
        const updates = [];

        rows.forEach((row) => {
          const appNo = (row.querySelector('[data-field="app_no"]')?.textContent || "").trim();
          const label = (row.querySelector('[data-field="label"]')?.textContent || "").trim();
          const url = (row.querySelector('[data-field="url"]')?.textContent || "").trim();
          if (!appNo || !label || !url) return;
          if (seen.has(appNo)) return;
          seen.add(appNo);
          updates.push({ app_no: appNo, label, url });
        });

        if (!updates.length) {
          statusEl.textContent = "保存できる項目がありません。";
          return;
        }

        statusEl.textContent = "保存しています...";
        const { error } = await supabase.from("apps").upsert(updates, { onConflict: "app_no" });
        if (error) {
          statusEl.textContent = "保存に失敗しました。";
          console.error("Failed to save apps", error);
          return;
        }

        statusEl.textContent = "保存しました。";
        await loadAndRenderShortcuts(ctx.email, { preferEditMode: "apps" });
      });

      setEditMode("apps");
    };

    const renderUserManager = (ctx) => {
      if (!ctx?.canEditUsers) {
        setEditMode("");
        renderSignedIn({ email: ctx?.email || "", shortcuts: ctx?.shortcuts || [], canEditApps: ctx?.canEditApps || false, canEditUsers: false });
        return;
      }

      statusEl.textContent = `${ctx.email} さんはユーザー割当を編集できます。`;
      const userAppsRows = ctx.userApps || [];

      const renderUserRow = (item, idx) => `
        <tr data-index="${idx}">
          <td class="cell-num">${idx + 1}</td>
          <td class="cell-edit" contenteditable="true" data-field="email" spellcheck="false">${escapeHtml(item.email || "")}</td>
          <td class="cell-edit" contenteditable="true" data-field="app_no" spellcheck="false">${escapeHtml(item.app_no || "")}</td>
          <td class="cell-check"><input type="checkbox" data-field="allowed" ${item.allowed ? "checked" : ""} data-default="true" /></td>
          <td class="cell-check"><input type="checkbox" data-field="editor" ${item.editor ? "checked" : ""} /></td>
          <td class="cell-check"><input type="checkbox" data-field="admin" ${item.admin ? "checked" : ""} /></td>
        </tr>
      `;

      const blankUserRowCount = Math.max(3, 5 - userAppsRows.length);
      const existingUserRowsMarkup = userAppsRows.map(renderUserRow).join("\n");
      const blankUserRowsMarkup = Array.from({ length: blankUserRowCount })
        .map((_, i) => renderUserRow({ email: "", app_no: "", allowed: true, editor: false, admin: false }, userAppsRows.length + i))
        .join("\n");

      actionsEl.innerHTML = `
        <div class="editor-wrapper">
          <p class="muted">メールとApp Noを入れれば、allowedは自動でONにして保存します。Excel/スプレッドシートの行（メール / App No / allowed / editor / admin）をそのまま貼り付けできます。</p>
          <form id="users-form">
            <div class="table-wrapper">
              <table class="table-grid" id="users-table">
                <thead>
                  <tr>
                    <th>#</th>
                    <th>メール</th>
                    <th>App No</th>
                    <th>allowed</th>
                    <th>editor</th>
                    <th>admin</th>
                  </tr>
                </thead>
                <tbody id="users-tbody">
                  ${existingUserRowsMarkup}
                  ${blankUserRowsMarkup}
                </tbody>
              </table>
            </div>
            <div class="editor-actions inline-grid">
              <button class="btn-secondary" type="button" id="add-user-row">空行を1行追加</button>
              <button class="btn-secondary" type="button" id="add-five-user-rows">空行を5行追加</button>
              <button class="btn-primary" type="submit" id="save-users-btn">保存する</button>
            </div>
          </form>
          <div class="editor-actions">
            <button class="btn-ghost" type="button" id="back-from-users">一覧に戻る</button>
            <button class="btn-ghost" id="logout-btn">ログアウト</button>
          </div>
        </div>
      `;

      const tbody = document.getElementById("users-tbody");
      const addUserRow = (count = 1) => {
        if (!tbody) return;
        const start = tbody.querySelectorAll("tr").length;
        const rowsMarkup = Array.from({ length: count })
          .map((_, i) => renderUserRow({ email: "", app_no: "", allowed: true, editor: false, admin: false }, start + i))
          .join("\n");
        tbody.insertAdjacentHTML("beforeend", rowsMarkup);
      };

      setupGridPaste(
        tbody,
        [
          { key: "email", type: "text" },
          { key: "app_no", type: "text" },
          { key: "allowed", type: "bool", defaultTrue: true },
          { key: "editor", type: "bool" },
          { key: "admin", type: "bool" },
        ],
        () => addUserRow(1)
      );

      document.getElementById("add-user-row")?.addEventListener("click", () => addUserRow(1));
      document.getElementById("add-five-user-rows")?.addEventListener("click", () => addUserRow(5));

      const logoutBtn = document.getElementById("logout-btn");
      logoutBtn?.addEventListener("click", async () => {
        statusEl.textContent = "ログアウトしています...";
        await supabase.auth.signOut();
      });

      const backBtn = document.getElementById("back-from-users");
      backBtn?.addEventListener("click", () => {
        setEditMode("");
        renderSignedIn({ ...ctx });
      });

      const form = document.getElementById("users-form");
      form?.addEventListener("submit", async (event) => {
        event.preventDefault();
        const rows = Array.from(tbody?.querySelectorAll("tr") || []);
        const seen = new Set();
        const updates = [];

        rows.forEach((row) => {
          const emailVal = normalizeEmail((row.querySelector('[data-field="email"]')?.textContent || ""));
          const appNo = (row.querySelector('[data-field="app_no"]')?.textContent || "").trim();
          const allowed = row.querySelector('input[data-field="allowed"]')?.checked ?? false;
          const editor = row.querySelector('input[data-field="editor"]')?.checked ?? false;
          const admin = row.querySelector('input[data-field="admin"]')?.checked ?? false;
          if (!emailVal || !appNo) return;
          const key = `${emailVal}__${appNo}`;
          if (seen.has(key)) return;
          seen.add(key);
          updates.push({ email: emailVal, app_no: appNo, allowed, editor, admin });
        });

        if (!updates.length) {
          statusEl.textContent = "保存できる項目がありません。";
          return;
        }

        statusEl.textContent = "保存しています...";
        const { error } = await supabase.from("user_apps").upsert(updates, { onConflict: "email,app_no" });
        if (error) {
          statusEl.textContent = "保存に失敗しました。";
          console.error("Failed to save user_apps", error);
          return;
        }

        statusEl.textContent = "保存しました。";
        await loadAndRenderShortcuts(ctx.email, { preferEditMode: "users" });
      });

      setEditMode("users");
    };

    const fetchAppData = async (email) => {
      const target = normalizeEmail(email || "");
      try {
        // 1) user_apps to know allowed/admin/editor flags
        const { data: userRows, error: userErr } = await supabase
          .from("user_apps")
          .select("app_no, allowed, editor, admin")
          .eq("email", target)
          .limit(300);

        if (userErr) throw userErr;

        const allowedRows = (userRows || []).filter((row) => row?.allowed === true);
        const appNos = Array.from(new Set(allowedRows.map((row) => (row.app_no || "").trim()).filter(Boolean))).slice(0, MAX_SHORTCUTS);

        const isAdmin = (userRows || []).some((row) => row?.admin === true);
        const canEditApps = isAdmin || allowedRows.length > 0;
        const canEditUsers = isAdmin;

        // 2) apps
        let apps = [];
        if (isAdmin) {
          const { data: appsAll, error: appsErr } = await supabase
            .from("apps")
            .select("app_no, label, url")
            .order("app_no", { ascending: true })
            .limit(300);
          if (appsErr) throw appsErr;
          apps = appsAll || [];
        } else if (appNos.length) {
          const { data: appRows, error: appErr } = await supabase
            .from("apps")
            .select("app_no, label, url")
            .in("app_no", appNos);
          if (appErr) throw appErr;
          apps = appRows || [];
        }

        // shortcuts (display only allowed rows)
        const appMap = new Map((apps || []).map((row) => [row.app_no, { label: row.label, url: row.url }]));
        const shortcuts = appNos
          .map((no) => {
            const app = appMap.get(no);
            return app ? { app_no: no, label: app.label || "", url: app.url || "" } : null;
          })
          .filter((row) => row && row.label && row.url);

        // 3) user_apps (full) for admin
        let userApps = [];
        if (isAdmin) {
          const { data: uaRows, error: uaErr } = await supabase
            .from("user_apps")
            .select("email, app_no, allowed, editor, admin")
            .order("email", { ascending: true })
            .limit(300);
          if (uaErr) throw uaErr;
          userApps = uaRows || [];
        }

        console.log(`Supabase user_apps for ${target}:`, userRows);
        console.log(`Resolved shortcuts:`, shortcuts);
        return { shortcuts, apps, userApps, isAdmin, canEditApps, canEditUsers };
      } catch (err) {
        console.error("Unexpected error fetching shortcuts", err);
        return { shortcuts: [], apps: [], userApps: [], isAdmin: false, canEditApps: false, canEditUsers: false };
      }
    };

    const loadAndRenderShortcuts = async (email, options = {}) => {
      statusEl.textContent = "リンクを取得しています...";
      const data = await fetchAppData(email);

      latestContext = { email, ...data };

      if (!(data.shortcuts || []).length) {
        console.warn("No shortcuts from sheet; showing fallback links.");
      }

      const mode = options.preferEditMode || getEditMode();
      if (mode === "users" && data.canEditUsers) {
        renderUserManager(latestContext);
        return;
      }
      if (mode === "apps" && data.canEditApps) {
        renderAppManager(latestContext);
        return;
      }

      if (!data.canEditApps && !data.canEditUsers) {
        setEditMode("");
      }
      renderSignedIn({ ...data, email });
    };

    const syncSession = async () => {
      const { data, error } = await supabase.auth.getSession();
      if (error) {
        statusEl.textContent = "セッションの取得に失敗しました。";
        actionsEl.innerHTML = "";
        console.error(error);
        return;
      }

      const email = data.session?.user?.email;
      if (email) {
        await loadAndRenderShortcuts(email);
      } else {
        renderSignedOut();
      }
    };

    await syncSession();

    supabase.auth.onAuthStateChange(async (event, session) => {
      const email = session?.user?.email;
      if (email) {
        await loadAndRenderShortcuts(email);
      } else {
        renderSignedOut();
      }
    });
  </script>
</body>
</html>
